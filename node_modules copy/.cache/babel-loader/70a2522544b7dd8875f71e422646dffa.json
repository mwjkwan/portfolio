{"ast":null,"code":"import _defineProperty from \"/Users/melissa/datamatch/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/melissa/datamatch/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nexport function numberWithCommas(x) {\n  var fixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  return x.toFixed(fixed).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\nexport function arrayToMap(array) {\n  return Object.assign.apply(Object, [{}].concat(_toConsumableArray(array.map(function (s) {\n    return _defineProperty({}, s.id, s);\n  }))));\n}\nexport var sortArrayOfObjects = function sortArrayOfObjects(array, parameter) {\n  function compare(a, b) {\n    if (a[parameter] < b[parameter]) {\n      return -1;\n    }\n\n    if (a[parameter] > b[parameter]) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  var arrayClone = JSON.parse(JSON.stringify(array));\n  arrayClone.sort(compare);\n  return arrayClone;\n};\nexport function deepCompare() {\n  var i, l, leftChain, rightChain;\n\n  function compare2Objects(x, y) {\n    var p; // remember that NaN === NaN returns false\n    // and isNaN(undefined) returns true\n\n    if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {\n      return true;\n    } // Compare primitives and functions.\n    // Check if both arguments link to the same object.\n    // Especially useful on the step where we compare prototypes\n\n\n    if (x === y) {\n      return true;\n    } // Works in case when functions are created in constructor.\n    // Comparing dates is a common scenario. Another built-ins?\n    // We can even handle functions passed across iframes\n\n\n    if (typeof x === 'function' && typeof y === 'function' || x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || x instanceof String && y instanceof String || x instanceof Number && y instanceof Number) {\n      return x.toString() === y.toString();\n    } // At last checking prototypes as good as we can\n\n\n    if (!(x instanceof Object && y instanceof Object)) {\n      return false;\n    }\n\n    if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {\n      return false;\n    }\n\n    if (x.constructor !== y.constructor) {\n      return false;\n    }\n\n    if (x.prototype !== y.prototype) {\n      return false;\n    } // Check for infinitive linking loops\n\n\n    if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {\n      return false;\n    } // Quick checking of one object being a subset of another.\n    // todo: cache the structure of arguments[0] for performance\n\n\n    for (p in y) {\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n        return false;\n      } else if (typeof y[p] !== typeof x[p]) {\n        return false;\n      }\n    }\n\n    for (p in x) {\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n        return false;\n      } else if (typeof y[p] !== typeof x[p]) {\n        return false;\n      }\n\n      switch (typeof x[p]) {\n        case 'object':\n        case 'function':\n          leftChain.push(x);\n          rightChain.push(y);\n\n          if (!compare2Objects(x[p], y[p])) {\n            return false;\n          }\n\n          leftChain.pop();\n          rightChain.pop();\n          break;\n\n        default:\n          if (x[p] !== y[p]) {\n            return false;\n          }\n\n          break;\n      }\n    }\n\n    return true;\n  }\n\n  if (arguments.length < 1) {\n    return true; //Die silently? Don't know how to handle such case, please help...\n    // throw \"Need two or more arguments to compare\";\n  }\n\n  for (i = 1, l = arguments.length; i < l; i++) {\n    leftChain = []; //Todo: this can be cached\n\n    rightChain = [];\n\n    if (!compare2Objects(arguments[0], arguments[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar randInt = function randInt() {\n  return Math.floor(Math.random() * Math.floor(36));\n};\n\nexport var generateCode = function generateCode() {\n  var code = '';\n\n  for (var i = 0; i < 8; ++i) {\n    var digit = randInt();\n\n    if (digit < 10) {\n      code += digit.toString();\n    } else {\n      code += String.fromCharCode(digit - 10 + 65);\n    }\n  }\n\n  return code;\n};\nexport var wait = function wait(ms) {\n  return new Promise(function (r, _j) {\n    return setTimeout(r, ms);\n  });\n};","map":{"version":3,"sources":["/Users/melissa/datamatch/src/utils/helpers.js"],"names":["numberWithCommas","x","fixed","toFixed","toString","replace","arrayToMap","array","Object","assign","map","s","id","sortArrayOfObjects","parameter","compare","a","b","arrayClone","JSON","parse","stringify","sort","deepCompare","i","l","leftChain","rightChain","compare2Objects","y","p","isNaN","Date","RegExp","String","Number","isPrototypeOf","constructor","prototype","indexOf","hasOwnProperty","push","pop","arguments","length","randInt","Math","floor","random","generateCode","code","digit","fromCharCode","wait","ms","Promise","r","_j","setTimeout"],"mappings":";;AAAA,OAAO,SAASA,gBAAT,CAA0BC,CAA1B,EAAwC;AAAA,MAAXC,KAAW,uEAAH,CAAG;AAC7C,SAAOD,CAAC,CACLE,OADI,CACID,KADJ,EAEJE,QAFI,GAGJC,OAHI,CAGI,uBAHJ,EAG6B,GAH7B,CAAP;AAID;AAED,OAAO,SAASC,UAAT,CAAoBC,KAApB,EAA2B;AAChC,SAAOC,MAAM,CAACC,MAAP,OAAAD,MAAM,GAAQ,EAAR,4BAAeD,KAAK,CAACG,GAAN,CAAU,UAAAC,CAAC;AAAA,+BAAQA,CAAC,CAACC,EAAV,EAAeD,CAAf;AAAA,GAAX,CAAf,GAAb;AACD;AAED,OAAO,IAAME,kBAAkB,GAAG,SAArBA,kBAAqB,CAACN,KAAD,EAAQO,SAAR,EAAsB;AACtD,WAASC,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AACrB,QAAID,CAAC,CAACF,SAAD,CAAD,GAAeG,CAAC,CAACH,SAAD,CAApB,EAAiC;AAC/B,aAAO,CAAC,CAAR;AACD;;AACD,QAAIE,CAAC,CAACF,SAAD,CAAD,GAAeG,CAAC,CAACH,SAAD,CAApB,EAAiC;AAC/B,aAAO,CAAP;AACD;;AACD,WAAO,CAAP;AACD;;AAED,MAAII,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAed,KAAf,CAAX,CAAjB;AACAW,EAAAA,UAAU,CAACI,IAAX,CAAgBP,OAAhB;AAEA,SAAOG,UAAP;AACD,CAfM;AAiBP,OAAO,SAASK,WAAT,GAAuB;AAC5B,MAAIC,CAAJ,EAAOC,CAAP,EAAUC,SAAV,EAAqBC,UAArB;;AAEA,WAASC,eAAT,CAAyB3B,CAAzB,EAA4B4B,CAA5B,EAA+B;AAC7B,QAAIC,CAAJ,CAD6B,CAG7B;AACA;;AACA,QACEC,KAAK,CAAC9B,CAAD,CAAL,IACA8B,KAAK,CAACF,CAAD,CADL,IAEA,OAAO5B,CAAP,KAAa,QAFb,IAGA,OAAO4B,CAAP,KAAa,QAJf,EAKE;AACA,aAAO,IAAP;AACD,KAZ4B,CAc7B;AACA;AACA;;;AACA,QAAI5B,CAAC,KAAK4B,CAAV,EAAa;AACX,aAAO,IAAP;AACD,KAnB4B,CAqB7B;AACA;AACA;;;AACA,QACG,OAAO5B,CAAP,KAAa,UAAb,IAA2B,OAAO4B,CAAP,KAAa,UAAzC,IACC5B,CAAC,YAAY+B,IAAb,IAAqBH,CAAC,YAAYG,IADnC,IAEC/B,CAAC,YAAYgC,MAAb,IAAuBJ,CAAC,YAAYI,MAFrC,IAGChC,CAAC,YAAYiC,MAAb,IAAuBL,CAAC,YAAYK,MAHrC,IAICjC,CAAC,YAAYkC,MAAb,IAAuBN,CAAC,YAAYM,MALvC,EAME;AACA,aAAOlC,CAAC,CAACG,QAAF,OAAiByB,CAAC,CAACzB,QAAF,EAAxB;AACD,KAhC4B,CAkC7B;;;AACA,QAAI,EAAEH,CAAC,YAAYO,MAAb,IAAuBqB,CAAC,YAAYrB,MAAtC,CAAJ,EAAmD;AACjD,aAAO,KAAP;AACD;;AAED,QAAIP,CAAC,CAACmC,aAAF,CAAgBP,CAAhB,KAAsBA,CAAC,CAACO,aAAF,CAAgBnC,CAAhB,CAA1B,EAA8C;AAC5C,aAAO,KAAP;AACD;;AAED,QAAIA,CAAC,CAACoC,WAAF,KAAkBR,CAAC,CAACQ,WAAxB,EAAqC;AACnC,aAAO,KAAP;AACD;;AAED,QAAIpC,CAAC,CAACqC,SAAF,KAAgBT,CAAC,CAACS,SAAtB,EAAiC;AAC/B,aAAO,KAAP;AACD,KAjD4B,CAmD7B;;;AACA,QAAIZ,SAAS,CAACa,OAAV,CAAkBtC,CAAlB,IAAuB,CAAC,CAAxB,IAA6B0B,UAAU,CAACY,OAAX,CAAmBV,CAAnB,IAAwB,CAAC,CAA1D,EAA6D;AAC3D,aAAO,KAAP;AACD,KAtD4B,CAwD7B;AACA;;;AACA,SAAKC,CAAL,IAAUD,CAAV,EAAa;AACX,UAAIA,CAAC,CAACW,cAAF,CAAiBV,CAAjB,MAAwB7B,CAAC,CAACuC,cAAF,CAAiBV,CAAjB,CAA5B,EAAiD;AAC/C,eAAO,KAAP;AACD,OAFD,MAEO,IAAI,OAAOD,CAAC,CAACC,CAAD,CAAR,KAAgB,OAAO7B,CAAC,CAAC6B,CAAD,CAA5B,EAAiC;AACtC,eAAO,KAAP;AACD;AACF;;AAED,SAAKA,CAAL,IAAU7B,CAAV,EAAa;AACX,UAAI4B,CAAC,CAACW,cAAF,CAAiBV,CAAjB,MAAwB7B,CAAC,CAACuC,cAAF,CAAiBV,CAAjB,CAA5B,EAAiD;AAC/C,eAAO,KAAP;AACD,OAFD,MAEO,IAAI,OAAOD,CAAC,CAACC,CAAD,CAAR,KAAgB,OAAO7B,CAAC,CAAC6B,CAAD,CAA5B,EAAiC;AACtC,eAAO,KAAP;AACD;;AAED,cAAQ,OAAO7B,CAAC,CAAC6B,CAAD,CAAhB;AACE,aAAK,QAAL;AACA,aAAK,UAAL;AACEJ,UAAAA,SAAS,CAACe,IAAV,CAAexC,CAAf;AACA0B,UAAAA,UAAU,CAACc,IAAX,CAAgBZ,CAAhB;;AAEA,cAAI,CAACD,eAAe,CAAC3B,CAAC,CAAC6B,CAAD,CAAF,EAAOD,CAAC,CAACC,CAAD,CAAR,CAApB,EAAkC;AAChC,mBAAO,KAAP;AACD;;AAEDJ,UAAAA,SAAS,CAACgB,GAAV;AACAf,UAAAA,UAAU,CAACe,GAAX;AACA;;AAEF;AACE,cAAIzC,CAAC,CAAC6B,CAAD,CAAD,KAASD,CAAC,CAACC,CAAD,CAAd,EAAmB;AACjB,mBAAO,KAAP;AACD;;AACD;AAlBJ;AAoBD;;AAED,WAAO,IAAP;AACD;;AAED,MAAIa,SAAS,CAACC,MAAV,GAAmB,CAAvB,EAA0B;AACxB,WAAO,IAAP,CADwB,CACX;AACb;AACD;;AAED,OAAKpB,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGkB,SAAS,CAACC,MAA1B,EAAkCpB,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5CE,IAAAA,SAAS,GAAG,EAAZ,CAD4C,CAC5B;;AAChBC,IAAAA,UAAU,GAAG,EAAb;;AAEA,QAAI,CAACC,eAAe,CAACe,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAACnB,CAAD,CAAxB,CAApB,EAAkD;AAChD,aAAO,KAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD;;AAED,IAAMqB,OAAO,GAAG,SAAVA,OAAU;AAAA,SAAMC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBF,IAAI,CAACC,KAAL,CAAW,EAAX,CAA3B,CAAN;AAAA,CAAhB;;AAEA,OAAO,IAAME,YAAY,GAAG,SAAfA,YAAe,GAAM;AAChC,MAAIC,IAAI,GAAG,EAAX;;AACA,OAAK,IAAI1B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;AAC1B,QAAI2B,KAAK,GAAGN,OAAO,EAAnB;;AACA,QAAIM,KAAK,GAAG,EAAZ,EAAgB;AACdD,MAAAA,IAAI,IAAIC,KAAK,CAAC/C,QAAN,EAAR;AACD,KAFD,MAEO;AACL8C,MAAAA,IAAI,IAAIhB,MAAM,CAACkB,YAAP,CAAoBD,KAAK,GAAG,EAAR,GAAa,EAAjC,CAAR;AACD;AACF;;AACD,SAAOD,IAAP;AACD,CAXM;AAaP,OAAO,IAAMG,IAAI,GAAG,SAAPA,IAAO,CAAAC,EAAE;AAAA,SAAI,IAAIC,OAAJ,CAAY,UAACC,CAAD,EAAIC,EAAJ;AAAA,WAAWC,UAAU,CAACF,CAAD,EAAIF,EAAJ,CAArB;AAAA,GAAZ,CAAJ;AAAA,CAAf","sourcesContent":["export function numberWithCommas(x, fixed = 2) {\n  return x\n    .toFixed(fixed)\n    .toString()\n    .replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\n\nexport function arrayToMap(array) {\n  return Object.assign({}, ...array.map(s => ({ [s.id]: s })));\n}\n\nexport const sortArrayOfObjects = (array, parameter) => {\n  function compare(a, b) {\n    if (a[parameter] < b[parameter]) {\n      return -1;\n    }\n    if (a[parameter] > b[parameter]) {\n      return 1;\n    }\n    return 0;\n  }\n\n  var arrayClone = JSON.parse(JSON.stringify(array));\n  arrayClone.sort(compare);\n\n  return arrayClone;\n};\n\nexport function deepCompare() {\n  var i, l, leftChain, rightChain;\n\n  function compare2Objects(x, y) {\n    var p;\n\n    // remember that NaN === NaN returns false\n    // and isNaN(undefined) returns true\n    if (\n      isNaN(x) &&\n      isNaN(y) &&\n      typeof x === 'number' &&\n      typeof y === 'number'\n    ) {\n      return true;\n    }\n\n    // Compare primitives and functions.\n    // Check if both arguments link to the same object.\n    // Especially useful on the step where we compare prototypes\n    if (x === y) {\n      return true;\n    }\n\n    // Works in case when functions are created in constructor.\n    // Comparing dates is a common scenario. Another built-ins?\n    // We can even handle functions passed across iframes\n    if (\n      (typeof x === 'function' && typeof y === 'function') ||\n      (x instanceof Date && y instanceof Date) ||\n      (x instanceof RegExp && y instanceof RegExp) ||\n      (x instanceof String && y instanceof String) ||\n      (x instanceof Number && y instanceof Number)\n    ) {\n      return x.toString() === y.toString();\n    }\n\n    // At last checking prototypes as good as we can\n    if (!(x instanceof Object && y instanceof Object)) {\n      return false;\n    }\n\n    if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {\n      return false;\n    }\n\n    if (x.constructor !== y.constructor) {\n      return false;\n    }\n\n    if (x.prototype !== y.prototype) {\n      return false;\n    }\n\n    // Check for infinitive linking loops\n    if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {\n      return false;\n    }\n\n    // Quick checking of one object being a subset of another.\n    // todo: cache the structure of arguments[0] for performance\n    for (p in y) {\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n        return false;\n      } else if (typeof y[p] !== typeof x[p]) {\n        return false;\n      }\n    }\n\n    for (p in x) {\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n        return false;\n      } else if (typeof y[p] !== typeof x[p]) {\n        return false;\n      }\n\n      switch (typeof x[p]) {\n        case 'object':\n        case 'function':\n          leftChain.push(x);\n          rightChain.push(y);\n\n          if (!compare2Objects(x[p], y[p])) {\n            return false;\n          }\n\n          leftChain.pop();\n          rightChain.pop();\n          break;\n\n        default:\n          if (x[p] !== y[p]) {\n            return false;\n          }\n          break;\n      }\n    }\n\n    return true;\n  }\n\n  if (arguments.length < 1) {\n    return true; //Die silently? Don't know how to handle such case, please help...\n    // throw \"Need two or more arguments to compare\";\n  }\n\n  for (i = 1, l = arguments.length; i < l; i++) {\n    leftChain = []; //Todo: this can be cached\n    rightChain = [];\n\n    if (!compare2Objects(arguments[0], arguments[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst randInt = () => Math.floor(Math.random() * Math.floor(36));\n\nexport const generateCode = () => {\n  let code = '';\n  for (let i = 0; i < 8; ++i) {\n    let digit = randInt();\n    if (digit < 10) {\n      code += digit.toString();\n    } else {\n      code += String.fromCharCode(digit - 10 + 65);\n    }\n  }\n  return code;\n};\n\nexport const wait = ms => new Promise((r, _j) => setTimeout(r, ms));\n"]},"metadata":{},"sourceType":"module"}